package api

import (
	"encoding/json"
	"fmt"
	"net/http"
	"net/http/httptest"
	"os"
	"strings"
	"testing"

	"golang.org/x/crypto/bcrypt"

	"tenant/internal/models"
	"tenant/internal/store"
)

var testDBCounter int

// setupTestAPI creates a test API with a file-based SQLite database
func setupTestAPI(t *testing.T) (*API, *store.Store, string, func()) {
	t.Helper()

	testDBCounter++
	dbPath := fmt.Sprintf("test_%d.db", testDBCounter)

	cfg := store.Config{
		Backend:    store.BackendSQLite,
		SQLitePath: dbPath,
	}

	s, err := store.New(cfg)
	if err != nil {
		t.Fatalf("Failed to create store: %v", err)
	}

	// Create test user - ID will be generated by CreateUser
	testUser := &models.User{
		Username:     "testuser",
		Email:        "test@example.com",
		PasswordHash: "$2a$10$test", // fake hash
		IsAdmin:      true,
	}
	if err := s.CreateUser(testUser); err != nil {
		t.Fatalf("Failed to create test user: %v", err)
	}

	api := New(s)

	cleanup := func() {
		s.Close()
		os.Remove(dbPath)
	}

	// Return the generated user ID
	return api, s, testUser.ID, cleanup
}

// createTestAPIKey creates an API key and returns the raw key for testing
func createTestAPIKey(t *testing.T, s *store.Store, userID, name string, scopes []string) string {
	t.Helper()

	key := &models.APIKey{
		UserID: userID,
		Name:   name,
		Scopes: scopes,
	}

	// Generate a raw key
	rawKey, err := generateAPIKey()
	if err != nil {
		t.Fatalf("Failed to generate API key: %v", err)
	}

	// Hash with bcrypt
	keyHash, err := bcrypt.GenerateFromPassword([]byte(rawKey), bcrypt.DefaultCost)
	if err != nil {
		t.Fatalf("Failed to hash API key: %v", err)
	}

	if err := s.CreateAPIKey(key, rawKey, string(keyHash)); err != nil {
		t.Fatalf("Failed to create API key: %v", err)
	}

	return rawKey
}

func TestAPIKeyValidAuth(t *testing.T) {
	api, s, userID, cleanup := setupTestAPI(t)
	defer cleanup()

	rawKey := createTestAPIKey(t, s, userID, "Test Key", []string{"things:read", "kinds:read"})

	req := httptest.NewRequest("GET", "/things", nil)
	req.Header.Set("Authorization", "Bearer "+rawKey)
	w := httptest.NewRecorder()

	api.Routes().ServeHTTP(w, req)

	if w.Code != http.StatusOK {
		t.Errorf("Expected status 200, got %d: %s", w.Code, w.Body.String())
	}
}

func TestAPIKeyInvalidAuth(t *testing.T) {
	api, _, _, cleanup := setupTestAPI(t)
	defer cleanup()

	req := httptest.NewRequest("GET", "/things", nil)
	req.Header.Set("Authorization", "Bearer ts_invalid_key_12345678901234567890123456789012")
	w := httptest.NewRecorder()

	api.Routes().ServeHTTP(w, req)

	if w.Code != http.StatusUnauthorized {
		t.Errorf("Expected status 401, got %d", w.Code)
	}

	var resp map[string]string
	json.NewDecoder(w.Body).Decode(&resp)
	if resp["error"] != "Invalid API key" {
		t.Errorf("Expected 'Invalid API key' error, got %s", resp["error"])
	}
}

func TestAPIKeyNoAuth(t *testing.T) {
	api, _, _, cleanup := setupTestAPI(t)
	defer cleanup()

	req := httptest.NewRequest("GET", "/things", nil)
	w := httptest.NewRecorder()

	api.Routes().ServeHTTP(w, req)

	if w.Code != http.StatusUnauthorized {
		t.Errorf("Expected status 401, got %d", w.Code)
	}
}

func TestAPIKeyReadScope(t *testing.T) {
	api, s, userID, cleanup := setupTestAPI(t)
	defer cleanup()

	rawKey := createTestAPIKey(t, s, userID, "Read Only Key", []string{"things:read"})

	req := httptest.NewRequest("GET", "/things", nil)
	req.Header.Set("Authorization", "Bearer "+rawKey)
	w := httptest.NewRecorder()

	api.Routes().ServeHTTP(w, req)

	if w.Code != http.StatusOK {
		t.Errorf("Expected status 200, got %d", w.Code)
	}
}

func TestAPIKeyWriteScopeMissing(t *testing.T) {
	api, s, userID, cleanup := setupTestAPI(t)
	defer cleanup()

	rawKey := createTestAPIKey(t, s, userID, "Read Only Key", []string{"things:read"})

	body := `{"type":"note","content":"Test"}`
	req := httptest.NewRequest("POST", "/things", strings.NewReader(body))
	req.Header.Set("Authorization", "Bearer "+rawKey)
	req.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()

	api.Routes().ServeHTTP(w, req)

	if w.Code != http.StatusForbidden {
		t.Errorf("Expected status 403 for missing write scope, got %d: %s", w.Code, w.Body.String())
	}
}

func TestAPIKeyWriteScope(t *testing.T) {
	api, s, userID, cleanup := setupTestAPI(t)
	defer cleanup()

	rawKey := createTestAPIKey(t, s, userID, "Read Write Key", []string{"things:read", "things:write"})

	body := `{"type":"note","content":"Test content"}`
	req := httptest.NewRequest("POST", "/things", strings.NewReader(body))
	req.Header.Set("Authorization", "Bearer "+rawKey)
	req.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()

	api.Routes().ServeHTTP(w, req)

	if w.Code != http.StatusCreated {
		t.Errorf("Expected status 201, got %d: %s", w.Code, w.Body.String())
	}
}

func TestAPIKeyAdminScope(t *testing.T) {
	api, s, userID, cleanup := setupTestAPI(t)
	defer cleanup()

	rawKey := createTestAPIKey(t, s, userID, "Admin Key", []string{}) // empty = admin

	// Can read
	req := httptest.NewRequest("GET", "/things", nil)
	req.Header.Set("Authorization", "Bearer "+rawKey)
	w := httptest.NewRecorder()
	api.Routes().ServeHTTP(w, req)
	if w.Code != http.StatusOK {
		t.Errorf("Admin key should be able to read, got %d", w.Code)
	}

	// Can write
	body := `{"type":"note","content":"Admin test"}`
	req = httptest.NewRequest("POST", "/things", strings.NewReader(body))
	req.Header.Set("Authorization", "Bearer "+rawKey)
	req.Header.Set("Content-Type", "application/json")
	w = httptest.NewRecorder()
	api.Routes().ServeHTTP(w, req)
	if w.Code != http.StatusCreated {
		t.Errorf("Admin key should be able to write, got %d: %s", w.Code, w.Body.String())
	}
}

func TestAPIKeyKindsRead(t *testing.T) {
	api, s, userID, cleanup := setupTestAPI(t)
	defer cleanup()

	rawKey := createTestAPIKey(t, s, userID, "Kinds Reader", []string{"kinds:read"})

	req := httptest.NewRequest("GET", "/kinds", nil)
	req.Header.Set("Authorization", "Bearer "+rawKey)
	w := httptest.NewRecorder()

	api.Routes().ServeHTTP(w, req)

	if w.Code != http.StatusOK {
		t.Errorf("Expected status 200, got %d", w.Code)
	}
}

func TestAPIKeyKindsReadForbidden(t *testing.T) {
	api, s, userID, cleanup := setupTestAPI(t)
	defer cleanup()

	rawKey := createTestAPIKey(t, s, userID, "No Kinds Access", []string{"things:read"})

	req := httptest.NewRequest("GET", "/kinds", nil)
	req.Header.Set("Authorization", "Bearer "+rawKey)
	w := httptest.NewRecorder()

	api.Routes().ServeHTTP(w, req)

	if w.Code != http.StatusForbidden {
		t.Errorf("Expected status 403, got %d", w.Code)
	}
}

func TestAuthStatus(t *testing.T) {
	api, _, _, cleanup := setupTestAPI(t)
	defer cleanup()

	req := httptest.NewRequest("GET", "/auth/status", nil)
	w := httptest.NewRecorder()

	api.Routes().ServeHTTP(w, req)

	if w.Code != http.StatusOK {
		t.Errorf("Expected status 200, got %d", w.Code)
	}

	var resp map[string]interface{}
	json.NewDecoder(w.Body).Decode(&resp)

	if resp["hasOwner"] != true {
		t.Error("Expected hasOwner to be true")
	}
}
